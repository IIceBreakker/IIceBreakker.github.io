<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IIceBreakker</title>
  
  <subtitle>你知道我要说什么，来找我吧</subtitle>
  <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/"/>
  <updated>2023-04-13T01:48:37.610Z</updated>
  <id>https://github.com/IIceBreakker/IIceBreakker.github.io/</id>
  
  <author>
    <name>IIceBreakker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件设计师-软件工程基础</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2023/03/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2023/03/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-21T15:45:05.000Z</published>
    <updated>2023-04-13T01:48:37.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件生存周期"><a href="#软件生存周期" class="headerlink" title="软件生存周期"></a>软件生存周期</h3><ol><li><p>可行性分析与项目开发计划<br>参与人员 -&gt; 用户、项目负责人、系统分析师<br>产出 -&gt; 可行性分析文档、项目开发计划</p></li><li><p>需求分析<br>目的 -&gt; 确定系统的逻辑模型<br>产出 -&gt; 软件需求说明书</p></li><li><p>概要设计<br>参与人员 -&gt; 系统分析师、软件设计师<br>产出 -&gt; 概要设计说明书</p></li><li><p>详细设计<br>参与人员 -&gt; 软件设计师、程序员<br>产出 -&gt; 详细设计文档</p></li><li><p>编码 &#x3D;&gt; 测试 &#x3D;&gt; 维护</p></li></ol><h3 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h3><ol><li><p>能力成熟度模型(CMM)<br>诊断工具 -&gt; 成熟度调查表等</p></li><li><p>能力成熟度模型继承(CMMI)<br>阶段式模型 -&gt; 类CMM直接分等级 5个成熟度等级<br>连续式模型 -&gt; 每个单独的过程都有6过程域能力等级 0-5</p></li></ol><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h3><h4 id="瀑布模型-Waterfall-Mode"><a href="#瀑布模型-Waterfall-Mode" class="headerlink" title="瀑布模型 Waterfall Mode"></a>瀑布模型 Waterfall Mode</h4><p>概述 -&gt; 完整的执行整个软件生存周期，如同瀑布流水逐级下落<br>适用 -&gt; 文档驱动，适用于软件需求很明确的项目<br>优点 -&gt; 容易理解，管理成本低<br>缺点 -&gt; 过于强调正规的流程，很多需求难以评估，而且很多需求错误只有到了后期才能被发现，容易导致项目延期<br>补充 -&gt; 变体V模型，左侧向下按着软件需求建模，概要设计，详细设计，编码进行；随着编码完成，右侧向上按照单元测试，集成测试，系统测试，验收测试验证左侧的每个阶段</p><h4 id="1-增量模型-Incremental-Mode"><a href="#1-增量模型-Incremental-Mode" class="headerlink" title="1.增量模型 Incremental Mode"></a>1.增量模型 Incremental Mode</h4><p>概述 -&gt; 将需求拆分成可按时间迭代的小需求，每次迭代按照瀑布模型产出一个可操作的产品<br>优点 -&gt; 具有Waterfall的所有优点。第一个可交付版本所需时间和成本很少；开发增量小系统风险小；增量投资，可以只对一个或两个增量投资。<br>缺点 -&gt; 不对用户的变更要求进行规划的话，初始增量可能造成后来的增量不稳定；一些增量可能要重新开发，重新开发；管理成本、进度和配置负复杂性超过组织能力。</p><h4 id="2-演化模型-Evolutionary-Mode"><a href="#2-演化模型-Evolutionary-Mode" class="headerlink" title="2.演化模型 Evolutionary Mode"></a>2.演化模型 Evolutionary Mode</h4><h5 id="原型模型-Prototype-Mode"><a href="#原型模型-Prototype-Mode" class="headerlink" title="原型模型 Prototype Mode"></a>原型模型 Prototype Mode</h5><p>适用 -&gt;  用户需求不清、需求经常变化的情况；系统规模不大不复杂<br>分类 -&gt; 探索型原型 &#x3D;&gt; 弄清目标要求，确定希望的特性，探讨多种方案的可行性<br>     -&gt; 实验型原型 &#x3D;&gt; 验证方案或算法的合理性，用于大规模开发前考察方案是否合适<br>     -&gt; 演化型原型 &#x3D;&gt; 将原型演化至最终目标系统</p><h5 id="螺旋模型-Spiral-Mode"><a href="#螺旋模型-Spiral-Mode" class="headerlink" title="螺旋模型 Spiral Mode"></a>螺旋模型 Spiral Mode</h5><p>概述 -&gt; 螺旋执行4个步骤，类增量模型；<br>     -&gt; 制定计划。确定软件目标，选定实施方案，明确项目开发限制<br>     -&gt; 风险分析。重点引进流程。<br>     -&gt; 实施工程。软件开发，验证阶段性产品<br>适用 -&gt; 强调风险分析，庞大、复杂、高风险的系统<br>优点 -&gt; 支持用户需求动态变化，为项目管理人员及时调整管理决策提供了遍历，降低了风险。<br>缺点 -&gt; 需要开发人员具有相当丰富的风险评估经验和专门知识，过多的迭代也会延迟提交时间</p><h4 id="3-喷泉模型-Water-Fountain-Mode"><a href="#3-喷泉模型-Water-Fountain-Mode" class="headerlink" title="3.喷泉模型 Water Fountain Mode"></a>3.喷泉模型 Water Fountain Mode</h4><p>概述 -&gt; 用户需求为动力， <strong>对象</strong>作为驱动，适合<strong>面向对象</strong>开发</p><p>优点 -&gt; 克服了瀑布模型不支持软件重弄用和多项开发活动集成的局限性<br>     -&gt; 使开发过程有迭代性，多次开发活动需要重复多次<br>     -&gt; 开发活动不具有明显的边界，允许交叉进行<br>     -&gt; 开发人员可以同步进行，提高效率，节省时间<br>缺点 -&gt; 各个阶段是重叠的，开发过程需要大量开发人员，不利于管理<br>     -&gt; 严格要求文档，使得审核难度加大</p><h4 id="4-基于构件的开发模型-Component-based-Development-Mode"><a href="#4-基于构件的开发模型-Component-based-Development-Mode" class="headerlink" title="4.基于构件的开发模型 Component based Development Mode"></a>4.基于构件的开发模型 Component based Development Mode</h4><p>概述 -&gt; 采用预先打包的额软件构件开发应用系统<br>包括 -&gt; 领域工程 &#x3D;&gt; 构件领域模型、领域基准体系结构和可复用构件库。<br>     -&gt; 应用系统工程 &#x3D;&gt; 使用可复用构件组装应用系统。</p><h4 id="5-形式化方法模型-Formal-Methods-Model"><a href="#5-形式化方法模型-Formal-Methods-Model" class="headerlink" title="5.形式化方法模型 Formal Methods Model"></a>5.形式化方法模型 Formal Methods Model</h4><p>概述 -&gt; 形式化方法建立在严格数学基础上，主要活动是生成计算机软件形式化的数学规格说明</p><h4 id="6-统一过程模型-UP"><a href="#6-统一过程模型-UP" class="headerlink" title="6.统一过程模型 UP"></a>6.统一过程模型 UP</h4><p>概述 -&gt; 用例和风险驱动，架构为中心，迭代并且增量的开发过程，有UML方法和工具支持，将整个软件开发项目分成许多个小的“袖珍项目”</p><p>4个技术阶段及其制品 -&gt; 起始阶段 &#x3D;&gt; 产生构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划、业务模型以及一个或多个原型<br>                   -&gt; 精化阶段 &#x3D;&gt; 产生用例模型、补充需求、分析模型、软件体系结果描述、。。。。<br>                   -&gt; 构建阶段 &#x3D;&gt; 产生设计模型、软件构件、集成的软件增量、测试计划、测试用例以及支持文档<br>                   -&gt; 移交阶段 &#x3D;&gt; 提交的软件增量、贝塔测试和综合用户反馈</p><h4 id="7-敏捷开发-Agile-Development"><a href="#7-敏捷开发-Agile-Development" class="headerlink" title="7.敏捷开发 Agile Development"></a>7.敏捷开发 Agile Development</h4><p>目标 -&gt; 尽可能早地、持续地对有价值的软件的交付。使用户能够在开发周期后期增加或改变需求<br>典型方法 -&gt; 极限编程 XP &#x3D;&gt; 4大价值观、5个原则、12个最佳实践<br>         -&gt; 水晶法 Crystal &#x3D;&gt; 每个不同的项目需要一套不同的策略、约定和方法论；认为人对软件质量有重要的影响<br>         -&gt; 并列争求法 Scrum &#x3D;&gt; 30天一次的迭代称为一个“冲刺”；多个自组织和自治的小组<strong>并行地</strong>递增实现产品。协调是通过简短的日常会议进行。<br>         -&gt; 自适应软件开发 ASD &#x3D;&gt; 6个基本原则<br>         -&gt; 敏捷统一过程 AUP &#x3D;&gt; 建模， 实现，测试，部署，配置及项目管理，环境管理</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>略</p><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>分为两种 -&gt; 面向数据流的结构化设计方法（Structured Design）<br>         -&gt; 面向对象的分析方法（OOD）</p><h4 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h4><p>1.设计软件系统总体结构 -&gt; 采用某种设计方法，将复杂系统分成模块<br>                    -&gt; 确定每个模块的功能<br>                    -&gt; 确定模块的调用关系<br>                    -&gt; 确定模块之间的接口，即模块之间传递的信息<br>                    -&gt; 评价模块结构的质量<br>2.数据结构及数据库设计 -&gt; 数据结构的设计，采用抽象数据类型<br>                    -&gt; 数据库设计 &#x3D;&gt;  1、概念设计。自底向上从用户角度进行视图设计，采用E-R模型<br>                                  &#x3D;&gt; 2、逻辑设计。E-R模型独立于DNMS，要结合具体的DBMS特征来建立数据库的逻辑结构<br>                                  &#x3D;&gt; 3、物理设计。设计数据模式的物理细节，例如数据项存储要求、存取方法和索引的建立<br>3.编写概要设计文档 -&gt; 文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划<br>4.评审 -&gt; 对设计部分是否完整地实现了需求中的要求，设计方法的可行性，关键的处理以及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审。</p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><p>1.对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程详细算法出来<br>2.对模块内部的数据结构进行设计<br>3.对数据库进行物理设计，即确定数据库的物理机构<br>4.其他设计 &#x3D;&gt; 代码设计<br>          &#x3D;&gt; 输入&#x2F;输出设计<br>          &#x3D;&gt; 用户界面设计<br>5.编写详细设计说明书<br>6.评审，对处理过程的算法和数据库的物理结构都要评审<br>系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统（包括硬件设备和编制软件程序）的重要基础。</p><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><h4 id="传统软件的测试策略-单元测试-gt-集成测试-gt-确认测试-gt-系统测试"><a href="#传统软件的测试策略-单元测试-gt-集成测试-gt-确认测试-gt-系统测试" class="headerlink" title="传统软件的测试策略 单元测试 -&gt; 集成测试 -&gt; 确认测试 -&gt; 系统测试"></a>传统软件的测试策略 单元测试 -&gt; 集成测试 -&gt; 确认测试 -&gt; 系统测试</h4><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><p>5个内容 -&gt; 模块接口。保证了测试模块的数据流可以正常流入、流出<br>     -&gt; 局部数据结构。局部数据结构出错常见<br>     -&gt; 重要的执行路径。精心设计测试用例来发现是否有计算、比较或控制流等方面的错误<br>     -&gt; 出错处理。好的设计应该有对出错的处理的路径<br>     -&gt; 边界条件<br>过程 -&gt; 设计两种模块，<strong>驱动模块</strong>相当于主程序，<strong>桩模块</strong>（存根模块）用来模拟被测试的模块调用的。<strong>简而言之，测试用例输入驱动模块，驱动模块调用被测模块，被测模块调用桩模块。</strong></p><h5 id="集成测试-将所有模块组合起来测试"><a href="#集成测试-将所有模块组合起来测试" class="headerlink" title="集成测试 将所有模块组合起来测试"></a>集成测试 将所有模块组合起来测试</h5><p>两种方法 -&gt; 非增量集成 &#x3D;&gt; 分别测试单个模块，再组合起来进行整体测试<br>                     &#x3D;&gt; 优点 充分利用人力，加快工程进度<br>                     &#x3D;&gt; 缺点 容易混乱，错误不容易定位<br>        -&gt; 增量集成 &#x3D;&gt; 小增量方式逐步进行构造和测试。<br>                   &#x3D;&gt; 优点 容易定位错误，易于对接口彻底测试，并且运用系统化的测试方法</p><p>4个增量测试策略 –&gt;</p><p>1.<strong>自顶向下集成测试</strong> -&gt; 构造软件体系结构的增量方法。。从主控模块开始，沿着控制层次逐步向下，以深度优先或广度优先将从属于主控模块的模块集成到结构中<br>2.<strong>自底向上继承测试</strong> -&gt; 不需要桩模块，自己就是桩模块<br>3.<strong>回归测试</strong> -&gt; 应当将回归测试用例设计成只包括设计每个主要程序功能的一个或多个错误类的测试<br>        -&gt; 包含以下3种测试用例 &#x3D;&gt; 能够测试软件所有功能的具有代表性的测试样本<br>                              &#x3D;&gt; 额外测试，侧重于可能会受变更影响的软件功能<br>                              &#x3D;&gt; 侧重于已发生变更的软件构件测试<br>4.<strong>冒烟测试</strong> -&gt; 时间关键项目的决定性机制<br>        -&gt; 先集成一个新的构建，设计一系列测试用例以暴露该构建的错误，每天将该构建与其他构建及真个软件集成起来进行冒烟测试。自底向上或者自顶向下都可以</p><h5 id="确认测试-此时传统软件、面向对象软件以及WebApp之间的差别已经消失，测试集中与用户可见的动作和用户可识别的系统输出"><a href="#确认测试-此时传统软件、面向对象软件以及WebApp之间的差别已经消失，测试集中与用户可见的动作和用户可识别的系统输出" class="headerlink" title="确认测试 此时传统软件、面向对象软件以及WebApp之间的差别已经消失，测试集中与用户可见的动作和用户可识别的系统输出"></a>确认测试 此时传统软件、面向对象软件以及WebApp之间的差别已经消失，测试集中与用户可见的动作和用户可识别的系统输出</h5><p>1.<strong>确认测试准则</strong>  -&gt; 测试计划列出将要执行的测试类</p><p>                -&gt; 测试规程定义了特定的测试用例</p><p>                -&gt; 设计的特定的测试用例用于确保满足所有的功能需求，具有所有的行为特征，所有内容准确无误且正确显示，达到所有性能要求，文档是正确可用的，且满足其他需求</p><p>2.<strong>配置评审</strong> -&gt; 主要是检查软件、文档和数据是否齐全以及分类是否有序。确保文档、资料的正确和完善，一遍维护阶段使用</p><p>3.<strong>α测试和β测试</strong> -&gt; <strong>α测试是由代表性的最终用户在开发者的场所进行</strong>，开发者全程记录，所以α测试是在受控的环境下进行的<br>              -&gt; <strong>β测试在一个或多个最终用户场所执行</strong>。开发者不在场，不受控的环境，其实就是经常说到的公测<br>              -&gt; <strong>β测试变体客户验收测试</strong>。例如一些政府机构，验收测试，非常正视</p><h5 id="系统测试-将已经确认的软件、计算机硬件、外设和网络等其他因素结合，进行各种集成测试和确认测试"><a href="#系统测试-将已经确认的软件、计算机硬件、外设和网络等其他因素结合，进行各种集成测试和确认测试" class="headerlink" title="系统测试 将已经确认的软件、计算机硬件、外设和网络等其他因素结合，进行各种集成测试和确认测试"></a>系统测试 将已经确认的软件、计算机硬件、外设和网络等其他因素结合，进行各种集成测试和确认测试</h5><p>1.恢复测试 -&gt; 通过一些手段强制让系统故障，验证是否能从错误中恢复过来，并在约定的时间开始事务处理，且不对系统造成任何伤害。若恢复是自动的的，就需要重新验证初始化、检查点和数据是否正确。如果恢复需要人工干预，就要对恢复的平均时间进行评估并判断是否在允许的范围内<br>2.安全性测试 -&gt; 测试人员模拟非法入侵者，采用各种方法冲破防线。其准则是攻破系统的代价要大于之后获取的价值。<br>3.压力测试 -&gt; 以非正常的数量，频率或容量等方式执行系统。<br>          -&gt; 变体 敏感性测试，试图在有效输入类中发现会引发系统不稳定或错误处理的数据组合<br>4.性能测试<br>5.部署测试 -&gt; 在软件将要运行的每一种环境中测试软件。另外，部署测试检查客户将要使用的所有安装程序及专业安装软件，并检查用于想最终用户介绍软件的所有文档。</p><h4 id="测试面向对象软件"><a href="#测试面向对象软件" class="headerlink" title="测试面向对象软件"></a>测试面向对象软件</h4><p>单元测试 -&gt; 封装的类是单元测试的重点，类中包括的操作是最小的可测试单元。面向对象的类测试是由封装在该类中的操作盒类的状态行为驱动的。</p><p>集成测试 -&gt; OOS没有明显层次控制结构，两种策略<br>        -&gt; 1.基于线程的测试，对响应系统的一个输入或时间所需的一组类进行集成，每个线程单独地集成和测试，并应用回归测试以确保没有副作用产生<br>        -&gt; 2.基于使用的测试，通过测试很少使用服务类的那些类开始系统的构建</p><h4 id="测试WebApp"><a href="#测试WebApp" class="headerlink" title="测试WebApp"></a>测试WebApp</h4><p>多种质量维度 -&gt; 内容、功能、结构、可用性、导航性、性能、兼容性、安全性<br>测试策略 -&gt; xxx</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>静态测试 -&gt; 包含人工检测和计算机辅助静态分析</p><h5 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h5><p>黑盒测试（功能测试） –&gt;<br>1.等价划分法 -&gt; 需要同时考虑有效等价类和无效等价类<br>2.边界值分析法 -&gt; 选取等价类划分法中的边界测试用例<br>3.错误推测 -&gt; 基于经验和直觉推测所有可能存在的各种错误<br>4.因果图法<br>白盒测试（结构测试） –&gt;<br>1.逻辑覆盖 -&gt; 语句覆盖、判定覆盖、判定&#x2F;条件覆盖、条件组合覆盖、路径覆盖（不一定现实，尤其是在循环中）<br>2.循环覆盖 -&gt;<br>3.基本路径测试 -&gt; 语句覆盖，并不需要路径排列组合</p><p><strong>环形复杂度（基本路径测试数量）</strong> -&gt; CC(G) &#x3D; E - N + 2<br>                            -&gt; CC(G) &#x3D; P + 1 P为原子判定节点</p><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><p>功能性 -&gt; 适合性、准确性、互用性、依从性、安全性<br>可靠性 -&gt; 成熟性、容错性、易恢复性<br>易使用性 -&gt; 易理解性、易学性、易操作性<br>效率 -&gt; 时间特性、资源特性<br>可维护性 -&gt; 易分析性、易改变性、稳定性、易测试性<br>可移植性 -&gt; 适应性、易安装性、一致性、易替换性</p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>Gantt图和PERT图</p><p>风险管理 -&gt; 识别风险的一种方法是风险检查条目表</p><p>        -&gt; 风险预测的一种技术是建立风险表 1表示灾难性，2表示严重的，3表示轻微的，4表示可忽略的</p><p>        -&gt; 风险控制最好的方法是主动地避免风险</p><h3 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h3><p>McCabe度量法 -&gt; 环路数 V(G) &#x3D; E - G + 2p</p><p>             -&gt; <strong>V(G) &#x3D; P + 1</strong></p><h3 id="结构化开发方法-面向数据流的开发方法"><a href="#结构化开发方法-面向数据流的开发方法" class="headerlink" title="结构化开发方法 面向数据流的开发方法"></a>结构化开发方法 面向数据流的开发方法</h3><p>概述 -&gt; 自顶向下、逐层分解，基本原则是功能的分解与抽象。<br>     -&gt; 软件工程最早出现的开发方法。适合处理数据处理领域的问题，不适合解决大规模的，特别复杂的项目，且难以适应需求的变化</p><p><strong>模块独立标准</strong></p><p>耦合性由弱到强 &#x3D;&gt; 无直接耦合 -&gt; 数据耦合（简单数据值，类似值传递） -&gt; 标记耦合（数据结构） -&gt; 控制耦合（控制变量，类似于执行命令） -&gt; 外部耦合（软件之外的环境联合，如IO设备连接模块） -&gt; 公共耦合（公共数据环境相互作用） -&gt; 内容耦合（直接使用另外的模块的数据）</p><p>内聚性由强到弱 &#x3D;&gt; 功能内聚 -&gt; 顺序内聚（密切相关且顺序执行） -&gt; 通信内聚（所有处理元素作用同一个数据结构） -&gt; 过程内聚（完成多个任务，必须按指定的过程进行）-&gt; 时间内聚（需要同时执行的动作组合在一起） -&gt; 逻辑内聚（若若干个逻辑相似的功能，用参数确定执行） -&gt; 偶然内聚（没有任何联系）</p><h3 id="面向对象的设计"><a href="#面向对象的设计" class="headerlink" title="面向对象的设计"></a>面向对象的设计</h3><h4 id="5大原则"><a href="#5大原则" class="headerlink" title="5大原则"></a>5大原则</h4><p>1.单一责任原则<br>2.开闭原则<br>3.里氏代换原则<br>4.依赖倒转原则<br>5.接口与分离原则</p><p>面向对象的软件测试4个层次</p><p>1.算法层。测试类中定义的每个方法，基本相当于传统软测的单元测试<br>2.类层。测试封装在同一个类中的所有方法与属性之间的调用。相当于模块测试<br>3.模板层。测试一组协同工作的类之间的相互作用。相当于集成测试。<br>4.系统层。把各个子系统组装成完整的面向对象软件。</p><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p>对象图 -&gt; 给出系统的静态设计视图或静态进程视图<br>      -&gt; 主要支持系统的功能需求，即系统应该提供给最终用户的服务<br>      -&gt; 利用对象图可以对静态数据结构建模</p><p>序列图 -&gt; 描述了以时间顺序组织的对象之间的交互活动</p><p>通信图 -&gt; 强调收发消息的对象的结构组织</p><p>交互概览图 -&gt; </p><p>计时图 -&gt; 适合实时和嵌入式系统建模的交互图，关注沿着线性时间轴、生命线内部和生命线之间的条件改变。<br>      -&gt; 描述对象状态随着时间改变的情况，很像示波器</p><p>状态图 -&gt; 由状态、转换、事件和活动组成<br>      -&gt; 关注系统的动态视图，对于接口、类和行为建模尤为重要，强调对象行为的事件顺序</p><p>活动图 -&gt; 活动状态和动作状态、转换和对象</p><h3 id="数据库的范式化"><a href="#数据库的范式化" class="headerlink" title="数据库的范式化"></a>数据库的范式化</h3><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><h4 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h4><p>第一范式 -&gt; 确保每列原子性，无重复列<br>第二范式 -&gt; 确保每列都和主键相关，完全依赖，所有非主属性都完全依赖一个候选关键字<br>第三范式 -&gt; 确保每列都和主键列直接相关，而不是间接相关，所有非主属性对任何候选关键字都不存在传递依赖</p><h4 id="并发控制技术"><a href="#并发控制技术" class="headerlink" title="并发控制技术"></a>并发控制技术</h4><h5 id="加锁-排它锁X锁-共享锁S锁"><a href="#加锁-排它锁X锁-共享锁S锁" class="headerlink" title="加锁 排它锁X锁 共享锁S锁"></a>加锁 排它锁X锁 共享锁S锁</h5><h5 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h5><p>一级封锁协议 -&gt; 修改数据R之前加X锁，事务结束释放。<br>            -&gt; 一级封锁协议可以解决丢失更新问题</p><p>二级封锁协议 -&gt; 一级基础上，读数据R之前加S锁，读完释放。<br>            -&gt; 解决了脏数据的问题，不能那个保证可重复读</p><p>三级封锁协议 -&gt; 一级基础上，读数据R之前加上S锁，事务结束释放。<br>            -&gt; 解决了丢失修改，脏数据，不可重复读的问题</p><h5 id="两段封锁协议"><a href="#两段封锁协议" class="headerlink" title="两段封锁协议"></a>两段封锁协议</h5><p>指所有事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一阶段获取锁，事务可以获取任何数据项上的任何锁，但不能释放；第二阶段释放锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>物理层的设备 -&gt; 中继器（Repeater），集线器（Hub）<br>数据链路层 -&gt; 网桥（Bridge），交换机（Switch）<br>网络层设备 -&gt; 路由器（Router）<br>应用层设备 -&gt; 网关（Gateway）</p><h4 id="TCP-x2F-IP协议簇"><a href="#TCP-x2F-IP协议簇" class="headerlink" title="TCP&#x2F;IP协议簇"></a>TCP&#x2F;IP协议簇</h4><h5 id="IP层协议"><a href="#IP层协议" class="headerlink" title="IP层协议"></a>IP层协议</h5><p>ARP和RARP -&gt; ARP将IP地址解析为物理地址，RARAP则刚好相反<br>ICMP协议（Ping工具） -&gt; 专门用于发送差错报文的协议<br>        -&gt; 5种差错报文（源抑制、超时目的不可达、重定向、要求分段）<br>        -&gt; 4种信息报文（回应请求、回应应答、地址屏蔽码请求、地址屏蔽码应答）<br>TCP协议 -&gt; 重发（Retransmission）技术实现可靠性<br>UDP协议 -&gt; 无连接，不可靠</p><h3 id="操作系统基本知识"><a href="#操作系统基本知识" class="headerlink" title="操作系统基本知识"></a>操作系统基本知识</h3><p>概述 -&gt; 处理机管理、文件管理、存储管理、设备管理、作业管理</p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>组成 -&gt; PCB，程序，数据</p><p>进程状态模型 -&gt; 三态，五态，具有挂起的4态</p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><strong>1.信号量机制</strong> </p><p>信号量S物理意义。S&gt;&#x3D;0代表某资源可用数，S&lt;0，其绝对值表示阻塞队列中等待该资源的进程数</p><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>高级调度 -&gt; 输入池哪个后备作业调入主系统做好运行准备，称为一个或一组就绪进程。一个作业只需经过一次高级调度<br>中级调度 -&gt; 交换区中的那个就绪进程调入内存。内存中处于阻塞状态的进程调出至交换区。<br>低级调度 -&gt; 决定内存中的那个就绪进程可以占用CPU</p><p><strong>调度算法</strong> </p><p>多级反馈队列 -&gt; 照顾了短进程以提高系统吞吐量、缩短平均周转时间<br>            -&gt; 照顾I&#x2F;O型进程以获得较好的I&#x2F;O设备利用率和缩短响应时间<br>            -&gt; 不必估计进程的执行时间，动态调节优先级</p><p>            -&gt; 前面的队列按照FSFS执行，一旦掉到最后一个队列，按照时间片轮转执行<br>            -&gt; 高优先级队列为空才执行低优先级队列。若执行过程中有新的来了，则抢占执行，先进程回到队列末尾</p><p>            -&gt; IO完成，提高优先级；时间片用完，降低优先级</p><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><h5 id="地址重定位-gt-逻辑地址变换成主存物理地址，由操作系统的装入程序Loader和地址重定位机构完成"><a href="#地址重定位-gt-逻辑地址变换成主存物理地址，由操作系统的装入程序Loader和地址重定位机构完成" class="headerlink" title="地址重定位 -&gt; 逻辑地址变换成主存物理地址，由操作系统的装入程序Loader和地址重定位机构完成"></a>地址重定位 -&gt; 逻辑地址变换成主存物理地址，由操作系统的装入程序Loader和地址重定位机构完成</h5><p><strong>静态重定位</strong> -&gt; 程序装入主存前已经完成逻辑地址到物理地址的变换<br><strong>动态重定位</strong> -&gt; 程序运行期间完成。依赖硬件地址变换机构，如基地址寄存器(BR)。</p><h5 id="存储管理方案"><a href="#存储管理方案" class="headerlink" title="存储管理方案"></a>存储管理方案</h5><p>分区存储管理</p><h6 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h6><p>纯分页存储管理</p><h6 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;软件生存周期&quot;&gt;&lt;a href=&quot;#软件生存周期&quot; class=&quot;headerlink&quot; title=&quot;软件生存周期&quot;&gt;&lt;/a&gt;软件生存周期&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可行性分析与项目开发计划&lt;br&gt;参与人员 -&amp;gt; 用户、项目负责人、系统分析师&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>华为经典面试题--双线程打印</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/30/200-05-30-%E5%8D%8E%E4%B8%BA%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%8C%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/30/200-05-30-%E5%8D%8E%E4%B8%BA%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%8C%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/</id>
    <published>2022-05-29T17:21:43.000Z</published>
    <updated>2022-06-28T13:42:15.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本题解法用来自我学习Java的一些多线程操作"><a href="#本题解法用来自我学习Java的一些多线程操作" class="headerlink" title="本题解法用来自我学习Java的一些多线程操作"></a>本题解法用来自我学习Java的一些多线程操作</h3><p><code>一个字母数组，一个数字数组，需要交叉打印两个数组得到值</code></p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本题解法用来自我学习Java的一些多线程操作&quot;&gt;&lt;a href=&quot;#本题解法用来自我学习Java的一些多线程操作&quot; class=&quot;headerlink&quot; title=&quot;本题解法用来自我学习Java的一些多线程操作&quot;&gt;&lt;/a&gt;本题解法用来自我学习Java的一些多线程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java基本知识</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/27/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/27/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</id>
    <published>2022-05-27T08:05:55.000Z</published>
    <updated>2022-06-28T08:00:02.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象在内存中的定位布局"><a href="#对象在内存中的定位布局" class="headerlink" title="对象在内存中的定位布局"></a>对象在内存中的定位布局</h2><p>一个对象的内存大小由四部分组成：</p><ul><li><font color="green">Markword</font>–64位虚拟机8个字节，32位虚拟机4个字节。其中包含锁，hashcode，GC信息</li><li><font color="green">class pointer</font>–4个字节，保存class信息</li><li><font color="green">instance data</font>–实例数据，引用类型地址为4个字节</li><li><font color="green">padding</font>–补充字节使得总字节数能被8整除</li></ul><p>对象创建过程三步：</p><ol><li>申请空间 new T</li><li>调构造方法设初始值 T.&lt;init&gt;</li><li>建立关联</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象在内存中的定位布局&quot;&gt;&lt;a href=&quot;#对象在内存中的定位布局&quot; class=&quot;headerlink&quot; title=&quot;对象在内存中的定位布局&quot;&gt;&lt;/a&gt;对象在内存中的定位布局&lt;/h2&gt;&lt;p&gt;一个对象的内存大小由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;fon</summary>
      
    
    
    
    <category term="Java基础" scheme="https://github.com/IIceBreakker/IIceBreakker.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Shiro和Spring Security</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/26/%E5%85%B3%E4%BA%8EShiro%E5%92%8CSpring-Security/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/26/%E5%85%B3%E4%BA%8EShiro%E5%92%8CSpring-Security/</id>
    <published>2022-05-26T02:19:37.000Z</published>
    <updated>2023-03-04T18:02:09.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Shiro认证的关键对象"><a href="#Shiro认证的关键对象" class="headerlink" title="Shiro认证的关键对象"></a>Shiro认证的关键对象</h3><ul><li><font color="green">Subject</font> 访问系统的用户</li><li><font color="green">Principal</font> 身份信息，是<strong>Subject</strong>进行身份认证的标识，必须具有唯一性，如用户名，一个<strong>Subject</strong>可以有多个<strong>Principal</strong>，但是必须有一个<strong>Primary Principal</strong></li><li><font color="green">Credential</font> 凭证信息，主要是密码</li></ul><span id="more"></span><h3 id="Shiro授权的关键对象"><a href="#Shiro授权的关键对象" class="headerlink" title="Shiro授权的关键对象"></a>Shiro授权的关键对象</h3><ul><li><p>权限字符串规则<code>资源标识符:操作:资源实例标识符</code>，例<code>user:create:*</code></p></li><li><p>RBAC Role-Based 基于角色访问控制</p><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (subject.hasRole(<span class="hljs-string">&quot;admin&quot;</span>)) &#123;  <span class="hljs-regexp">//</span> 操作资源&#125;</code></pre></li><li><p>RBAC Resource-Based 基于资源访问控制</p><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (subject.isPermission(&quot;<span class="hljs-attribute">user</span>:<span class="hljs-attribute">find</span>:*)) &#123;  <span class="hljs-comment">// 操作资源</span>&#125;</code></pre></li></ul><h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220724223502.png"></p><h3 id="认证核心对象"><a href="#认证核心对象" class="headerlink" title="认证核心对象"></a>认证核心对象</h3><ul><li><font color="green">AuthenticationManager</font> 主要实现类<strong>ProviderManager</strong>, 其管理了众多的<strong>AuthenticationProvider</strong>实例。在一次完整的认证流程中，SS允许存在多个<strong>AuthenticationProvider</strong>，用来实现多种认证方式。</li><li><font color="green">Authentication</font> 保存了认证以及认证成功的信息</li><li><font color="green">SecurityContextHolder</font> 用来获取登陆之后的用户信息，SS会将登录用户信息保存在sessio中，但是为了使用方便，SS做了一些改进，其中最主要的就是线程绑定。当用户登录成功后，SS会将用户信息保存到SCH中。SCH中的数据默认使用ThreadLocal，即用户数据和请求线程绑定。当登录请求处理完成后，Spring会将SCH中的用户信息拿出来存到Session中，同时清空SCH。以后每当有请求来到时，SS就会先从Session中取出用户登录信息，保存到SCH中，方便该请求的后续中使用，同时在请求结束时将SCH中的我数据清空。这一策略非常方便用户在代码中的任意地方获取当前登录用户信息。</li></ul><h3 id="授权核心对象"><a href="#授权核心对象" class="headerlink" title="授权核心对象"></a>授权核心对象</h3><ul><li><p><font color="green">AccessDecisionManager</font> 访问决策管理器，用来决定此次访问是否被允许。</p></li><li><p><font color="green">AccessDecisionVoter</font> 访问决定投票器，投票器会检查用户是否具备应有的角色，进而投出赞成、反对或者弃票权</p><p>这两者都有众多实现的类，在<code>Manager</code>中换个遍历<code>Voter</code>，进而决定是否允许用户访问。</p></li><li><p><font color="green">ConfigAttribute</font> 保存用户角色信息。在SS中，用户请求一个资源需要的角色会被封装成一个<code>ConfigAttribute</code>对象，在<code>ConfigAttribute</code>中只有一个<code>getAttribute</code>方法，该方法返回一个字符串，就是角色的名称。一般来说角色名称都带有一个<code>ROLE_</code>前缀，投票器所做的事情，其实就是比较用户所具的各个角色和请求某个资源所需的<code>ConfigAttribute</code>之间的关系。</p></li></ul><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a><strong>过滤器链</strong></h3><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/securityfilterchain.png"></p><p>默认的过滤器链并不是直接放在Web项目的原生过滤器链中，而是通过一个FilterChainProxy来统一管理。SS中的过滤器链通过FilterChainProxy嵌入到原生过滤器链中。<code>FilterChainProxy</code>作为一个顶层的管理者，将统一管理<code>SecurityFiter</code>。<code>FilterChainProxy</code>本身是通过Spring框架提供的<code>DelegatingFilterProxy</code>整合到原生的过滤器链中。</p><table><thead><tr><th>名称</th><th>作用</th><th>默认加载</th></tr></thead><tbody><tr><td>WebSyWebAsyncManagerIntegrationFilter</td><td>WebSyncManager与SpringSecurity上下文集成</td><td>YES</td></tr><tr><td>SecurityContextPersistenceFilter</td><td>处理请求之前将安全信息加载到SecurityContextHolder中</td><td>YES</td></tr><tr><td>HeaderWriterFilter</td><td>处理头信息加入响应中</td><td>YES</td></tr><tr><td>CorsFilter</td><td>处理跨域问题</td><td>NO</td></tr><tr><td>CsrfFilter</td><td>处理CSRF攻击</td><td>YES</td></tr><tr><td>LogoutFilter</td><td>处理注销登录</td><td>YES</td></tr><tr><td>UsernamePasswordAuthenticationFilter</td><td>处理表单登录</td><td>YES</td></tr><tr><td>DefaultLoginPageGeneratingFilter</td><td>配置默认登录页面</td><td>YES</td></tr><tr><td>DefaultLogoutPageGeneratingFilter</td><td>配置默认注销页面</td><td>YES</td></tr><tr><td>BasicAuthenticationFilter</td><td>处理HttpBasic登录</td><td>YES</td></tr><tr><td>RequestCacheAwareFilter</td><td>处理请求缓存</td><td>YES</td></tr><tr><td>SecurityContextHolderAwareRequestFilter</td><td>包装原始请求</td><td>YES</td></tr><tr><td>AnonymousAuthenticationFilter</td><td>配置匿名认证</td><td>YES</td></tr><tr><td>SessionManagementFilter</td><td>处理session并发问题</td><td>YES</td></tr><tr><td>ExceptionTranslationFilter</td><td>处理认证&#x2F;授权中的异常</td><td>YES</td></tr><tr><td>FilterSecurityInterceptor</td><td>处理授权相关</td><td>YES</td></tr></tbody></table><p>这些Filter在全部由一个叫<code>springSecurityFilterChain</code>的Bean加载进来。</p><h3 id="SpringBootWebSecurityConfiguration"><a href="#SpringBootWebSecurityConfiguration" class="headerlink" title="SpringBootWebSecurityConfiguration"></a>SpringBootWebSecurityConfiguration</h3><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220725005847.png"></p><p>这就是没配置任何东西请求会被拦截的原因，是在这里配置的。</p><p>这个类生效的条件是上面两个注解，主要是第一个</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220725010131.png"></p><p><code>WebSecurityConfigurationAdapter</code>很重要，所有的配置都是在这里实现的，<strong>但是未来将要被废除</strong></p><h3 id="默认登录界面怎么来的"><a href="#默认登录界面怎么来的" class="headerlink" title="默认登录界面怎么来的"></a>默认登录界面怎么来的</h3><ol><li><p>请求&#x2F;hello登陆接口</p></li><li><p>在请求到达时<code>FilterSecurityInterceptor</code>时，发现请求未认证。请求拦截下来，并抛出<code>AcessDeniedException</code></p></li><li><p>异常被<code>ExceptionTranslationFilter</code>拦截，该Filter中会调用<code>LoginUrlAuthenticationEntryPoint#commence</code>方法给客户端返回302，要求客户端进行重定向到&#x2F;login页面</p></li><li><p>客户端发送login请求且被<code>DefaultLoginPageGeneratingFilter</code>拦截到，并在拦截器中返回生成登录页面</p></li></ol><h2 id="默认用户生成"><a href="#默认用户生成" class="headerlink" title="默认用户生成"></a>默认用户生成</h2><p>默认<code>InMemoryUserDetailManager</code>来进行用户认证的</p><p>由<code>UserDetailsServiceAutoConfiguratio</code>配置生成</p><h2 id="自定义拦截规则"><a href="#自定义拦截规则" class="headerlink" title="自定义拦截规则"></a>自定义拦截规则</h2><p><code>WebSecurityConfigurerAdapter</code>写法，已经过时</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220728205533.png"></p><p><code>SecurityFilterChain</code>写法，还需要多摸索</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220728213244.png"></p><h2 id="自定义认证流程"><a href="#自定义认证流程" class="headerlink" title="自定义认证流程"></a>自定义认证流程</h2><p><a href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html">https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html</a></p><p>核心类<code>SecurityContextHolder</code></p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/securitycontextholder.png"></p><p>核心认证流程</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/abstractauthenticationprocessingfilter.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Shiro认证的关键对象&quot;&gt;&lt;a href=&quot;#Shiro认证的关键对象&quot; class=&quot;headerlink&quot; title=&quot;Shiro认证的关键对象&quot;&gt;&lt;/a&gt;Shiro认证的关键对象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Subject&lt;/font&gt; 访问系统的用户&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Principal&lt;/font&gt; 身份信息，是&lt;strong&gt;Subject&lt;/strong&gt;进行身份认证的标识，必须具有唯一性，如用户名，一个&lt;strong&gt;Subject&lt;/strong&gt;可以有多个&lt;strong&gt;Principal&lt;/strong&gt;，但是必须有一个&lt;strong&gt;Primary Principal&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Credential&lt;/font&gt; 凭证信息，主要是密码&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://github.com/IIceBreakker/IIceBreakker.github.io/categories/Security/"/>
    
    
  </entry>
  
</feed>
