<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IIceBreakker</title>
  
  <subtitle>你知道我要说什么，来找我吧</subtitle>
  <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/"/>
  <updated>2022-06-28T13:42:15.788Z</updated>
  <id>https://github.com/IIceBreakker/IIceBreakker.github.io/</id>
  
  <author>
    <name>IIceBreakker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>华为经典面试题--双线程打印</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/30/200-05-30-%E5%8D%8E%E4%B8%BA%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%8C%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/30/200-05-30-%E5%8D%8E%E4%B8%BA%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%8C%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/</id>
    <published>2022-05-29T17:21:43.000Z</published>
    <updated>2022-06-28T13:42:15.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本题解法用来自我学习Java的一些多线程操作"><a href="#本题解法用来自我学习Java的一些多线程操作" class="headerlink" title="本题解法用来自我学习Java的一些多线程操作"></a>本题解法用来自我学习Java的一些多线程操作</h3><p><code>一个字母数组，一个数字数组，需要交叉打印两个数组得到值</code></p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本题解法用来自我学习Java的一些多线程操作&quot;&gt;&lt;a href=&quot;#本题解法用来自我学习Java的一些多线程操作&quot; class=&quot;headerlink&quot; title=&quot;本题解法用来自我学习Java的一些多线程操作&quot;&gt;&lt;/a&gt;本题解法用来自我学习Java的一些多线程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java基本知识</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/27/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/27/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</id>
    <published>2022-05-27T08:05:55.000Z</published>
    <updated>2022-06-28T08:00:02.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象在内存中的定位布局"><a href="#对象在内存中的定位布局" class="headerlink" title="对象在内存中的定位布局"></a>对象在内存中的定位布局</h2><p>一个对象的内存大小由四部分组成：</p><ul><li><font color="green">Markword</font>–64位虚拟机8个字节，32位虚拟机4个字节。其中包含锁，hashcode，GC信息</li><li><font color="green">class pointer</font>–4个字节，保存class信息</li><li><font color="green">instance data</font>–实例数据，引用类型地址为4个字节</li><li><font color="green">padding</font>–补充字节使得总字节数能被8整除</li></ul><p>对象创建过程三步：</p><ol><li>申请空间 new T</li><li>调构造方法设初始值 T.&lt;init&gt;</li><li>建立关联</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象在内存中的定位布局&quot;&gt;&lt;a href=&quot;#对象在内存中的定位布局&quot; class=&quot;headerlink&quot; title=&quot;对象在内存中的定位布局&quot;&gt;&lt;/a&gt;对象在内存中的定位布局&lt;/h2&gt;&lt;p&gt;一个对象的内存大小由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;fon</summary>
      
    
    
    
    <category term="Java基础" scheme="https://github.com/IIceBreakker/IIceBreakker.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Shiro和Spring Security</title>
    <link href="https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/26/%E5%85%B3%E4%BA%8EShiro%E5%92%8CSpring-Security/"/>
    <id>https://github.com/IIceBreakker/IIceBreakker.github.io/2022/05/26/%E5%85%B3%E4%BA%8EShiro%E5%92%8CSpring-Security/</id>
    <published>2022-05-26T02:19:37.000Z</published>
    <updated>2023-03-04T18:02:09.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Shiro认证的关键对象"><a href="#Shiro认证的关键对象" class="headerlink" title="Shiro认证的关键对象"></a>Shiro认证的关键对象</h3><ul><li><font color="green">Subject</font> 访问系统的用户</li><li><font color="green">Principal</font> 身份信息，是<strong>Subject</strong>进行身份认证的标识，必须具有唯一性，如用户名，一个<strong>Subject</strong>可以有多个<strong>Principal</strong>，但是必须有一个<strong>Primary Principal</strong></li><li><font color="green">Credential</font> 凭证信息，主要是密码</li></ul><span id="more"></span><h3 id="Shiro授权的关键对象"><a href="#Shiro授权的关键对象" class="headerlink" title="Shiro授权的关键对象"></a>Shiro授权的关键对象</h3><ul><li><p>权限字符串规则<code>资源标识符:操作:资源实例标识符</code>，例<code>user:create:*</code></p></li><li><p>RBAC Role-Based 基于角色访问控制</p><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (subject.hasRole(<span class="hljs-string">&quot;admin&quot;</span>)) &#123;  <span class="hljs-regexp">//</span> 操作资源&#125;</code></pre></li><li><p>RBAC Resource-Based 基于资源访问控制</p><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (subject.isPermission(&quot;<span class="hljs-attribute">user</span>:<span class="hljs-attribute">find</span>:*)) &#123;  <span class="hljs-comment">// 操作资源</span>&#125;</code></pre></li></ul><h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220724223502.png"></p><h3 id="认证核心对象"><a href="#认证核心对象" class="headerlink" title="认证核心对象"></a>认证核心对象</h3><ul><li><font color="green">AuthenticationManager</font> 主要实现类<strong>ProviderManager</strong>, 其管理了众多的<strong>AuthenticationProvider</strong>实例。在一次完整的认证流程中，SS允许存在多个<strong>AuthenticationProvider</strong>，用来实现多种认证方式。</li><li><font color="green">Authentication</font> 保存了认证以及认证成功的信息</li><li><font color="green">SecurityContextHolder</font> 用来获取登陆之后的用户信息，SS会将登录用户信息保存在sessio中，但是为了使用方便，SS做了一些改进，其中最主要的就是线程绑定。当用户登录成功后，SS会将用户信息保存到SCH中。SCH中的数据默认使用ThreadLocal，即用户数据和请求线程绑定。当登录请求处理完成后，Spring会将SCH中的用户信息拿出来存到Session中，同时清空SCH。以后每当有请求来到时，SS就会先从Session中取出用户登录信息，保存到SCH中，方便该请求的后续中使用，同时在请求结束时将SCH中的我数据清空。这一策略非常方便用户在代码中的任意地方获取当前登录用户信息。</li></ul><h3 id="授权核心对象"><a href="#授权核心对象" class="headerlink" title="授权核心对象"></a>授权核心对象</h3><ul><li><p><font color="green">AccessDecisionManager</font> 访问决策管理器，用来决定此次访问是否被允许。</p></li><li><p><font color="green">AccessDecisionVoter</font> 访问决定投票器，投票器会检查用户是否具备应有的角色，进而投出赞成、反对或者弃票权</p><p>这两者都有众多实现的类，在<code>Manager</code>中换个遍历<code>Voter</code>，进而决定是否允许用户访问。</p></li><li><p><font color="green">ConfigAttribute</font> 保存用户角色信息。在SS中，用户请求一个资源需要的角色会被封装成一个<code>ConfigAttribute</code>对象，在<code>ConfigAttribute</code>中只有一个<code>getAttribute</code>方法，该方法返回一个字符串，就是角色的名称。一般来说角色名称都带有一个<code>ROLE_</code>前缀，投票器所做的事情，其实就是比较用户所具的各个角色和请求某个资源所需的<code>ConfigAttribute</code>之间的关系。</p></li></ul><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a><strong>过滤器链</strong></h3><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/securityfilterchain.png"></p><p>默认的过滤器链并不是直接放在Web项目的原生过滤器链中，而是通过一个FilterChainProxy来统一管理。SS中的过滤器链通过FilterChainProxy嵌入到原生过滤器链中。<code>FilterChainProxy</code>作为一个顶层的管理者，将统一管理<code>SecurityFiter</code>。<code>FilterChainProxy</code>本身是通过Spring框架提供的<code>DelegatingFilterProxy</code>整合到原生的过滤器链中。</p><table><thead><tr><th>名称</th><th>作用</th><th>默认加载</th></tr></thead><tbody><tr><td>WebSyWebAsyncManagerIntegrationFilter</td><td>WebSyncManager与SpringSecurity上下文集成</td><td>YES</td></tr><tr><td>SecurityContextPersistenceFilter</td><td>处理请求之前将安全信息加载到SecurityContextHolder中</td><td>YES</td></tr><tr><td>HeaderWriterFilter</td><td>处理头信息加入响应中</td><td>YES</td></tr><tr><td>CorsFilter</td><td>处理跨域问题</td><td>NO</td></tr><tr><td>CsrfFilter</td><td>处理CSRF攻击</td><td>YES</td></tr><tr><td>LogoutFilter</td><td>处理注销登录</td><td>YES</td></tr><tr><td>UsernamePasswordAuthenticationFilter</td><td>处理表单登录</td><td>YES</td></tr><tr><td>DefaultLoginPageGeneratingFilter</td><td>配置默认登录页面</td><td>YES</td></tr><tr><td>DefaultLogoutPageGeneratingFilter</td><td>配置默认注销页面</td><td>YES</td></tr><tr><td>BasicAuthenticationFilter</td><td>处理HttpBasic登录</td><td>YES</td></tr><tr><td>RequestCacheAwareFilter</td><td>处理请求缓存</td><td>YES</td></tr><tr><td>SecurityContextHolderAwareRequestFilter</td><td>包装原始请求</td><td>YES</td></tr><tr><td>AnonymousAuthenticationFilter</td><td>配置匿名认证</td><td>YES</td></tr><tr><td>SessionManagementFilter</td><td>处理session并发问题</td><td>YES</td></tr><tr><td>ExceptionTranslationFilter</td><td>处理认证&#x2F;授权中的异常</td><td>YES</td></tr><tr><td>FilterSecurityInterceptor</td><td>处理授权相关</td><td>YES</td></tr></tbody></table><p>这些Filter在全部由一个叫<code>springSecurityFilterChain</code>的Bean加载进来。</p><h3 id="SpringBootWebSecurityConfiguration"><a href="#SpringBootWebSecurityConfiguration" class="headerlink" title="SpringBootWebSecurityConfiguration"></a>SpringBootWebSecurityConfiguration</h3><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220725005847.png"></p><p>这就是没配置任何东西请求会被拦截的原因，是在这里配置的。</p><p>这个类生效的条件是上面两个注解，主要是第一个</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220725010131.png"></p><p><code>WebSecurityConfigurationAdapter</code>很重要，所有的配置都是在这里实现的，<strong>但是未来将要被废除</strong></p><h3 id="默认登录界面怎么来的"><a href="#默认登录界面怎么来的" class="headerlink" title="默认登录界面怎么来的"></a>默认登录界面怎么来的</h3><ol><li><p>请求&#x2F;hello登陆接口</p></li><li><p>在请求到达时<code>FilterSecurityInterceptor</code>时，发现请求未认证。请求拦截下来，并抛出<code>AcessDeniedException</code></p></li><li><p>异常被<code>ExceptionTranslationFilter</code>拦截，该Filter中会调用<code>LoginUrlAuthenticationEntryPoint#commence</code>方法给客户端返回302，要求客户端进行重定向到&#x2F;login页面</p></li><li><p>客户端发送login请求且被<code>DefaultLoginPageGeneratingFilter</code>拦截到，并在拦截器中返回生成登录页面</p></li></ol><h2 id="默认用户生成"><a href="#默认用户生成" class="headerlink" title="默认用户生成"></a>默认用户生成</h2><p>默认<code>InMemoryUserDetailManager</code>来进行用户认证的</p><p>由<code>UserDetailsServiceAutoConfiguratio</code>配置生成</p><h2 id="自定义拦截规则"><a href="#自定义拦截规则" class="headerlink" title="自定义拦截规则"></a>自定义拦截规则</h2><p><code>WebSecurityConfigurerAdapter</code>写法，已经过时</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220728205533.png"></p><p><code>SecurityFilterChain</code>写法，还需要多摸索</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/20220728213244.png"></p><h2 id="自定义认证流程"><a href="#自定义认证流程" class="headerlink" title="自定义认证流程"></a>自定义认证流程</h2><p><a href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html">https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html</a></p><p>核心类<code>SecurityContextHolder</code></p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/securitycontextholder.png"></p><p>核心认证流程</p><p><img src="https://iice-disk.oss-cn-beijing.aliyuncs.com/iice_images/abstractauthenticationprocessingfilter.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Shiro认证的关键对象&quot;&gt;&lt;a href=&quot;#Shiro认证的关键对象&quot; class=&quot;headerlink&quot; title=&quot;Shiro认证的关键对象&quot;&gt;&lt;/a&gt;Shiro认证的关键对象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Subject&lt;/font&gt; 访问系统的用户&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Principal&lt;/font&gt; 身份信息，是&lt;strong&gt;Subject&lt;/strong&gt;进行身份认证的标识，必须具有唯一性，如用户名，一个&lt;strong&gt;Subject&lt;/strong&gt;可以有多个&lt;strong&gt;Principal&lt;/strong&gt;，但是必须有一个&lt;strong&gt;Primary Principal&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Credential&lt;/font&gt; 凭证信息，主要是密码&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://github.com/IIceBreakker/IIceBreakker.github.io/categories/Security/"/>
    
    
  </entry>
  
</feed>
